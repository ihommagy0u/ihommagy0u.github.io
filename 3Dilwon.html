<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 인터랙티브 일원상</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 즉시 실행 함수 (IIFE)로 전체 코드를 감싸 변수 충돌을 방지합니다.
        (function() {
            // 1. 씬(Scene) 생성
            const scene = new THREE.Scene();

            // 2. 카메라(Camera) 생성
            // 원근감이 없는 OrthographicCamera를 사용하여 항상 완벽한 원으로 보이도록 합니다.
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 7;
            const camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 10;
            
            // 3. 렌더러(Renderer) 생성
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. 도형(Geometry) 및 재질(Material) 생성
            const R = 3; // 장반경
            const r = 0.1; // 단반경
            const goldenRatio = (1 + Math.sqrt(5)) / 2;
            const A = R / goldenRatio; // 진폭 (황금비율 적용)
            
            const points = [];
            const tubularSegments = 256;
            const radialSegments = 64;

            // ParametricEquation을 사용하여 휘어진 토러스 형태 생성
            class CustomTorusCurve extends THREE.Curve {
                constructor(scale = 1) {
                    super();
                    this.scale = scale;
                }
                getPoint(t) {
                    const u = t * 2 * Math.PI;
                    const x = (R + r * Math.cos(0)) * Math.cos(u);
                    const y = (R + r * Math.cos(0)) * Math.sin(u);
                    const z = A * Math.sin(2 * u);
                    return new THREE.Vector3(x, y, z).multiplyScalar(this.scale);
                }
            }
            
            const path = new CustomTorusCurve(1);
            const geometry = new THREE.TubeGeometry(path, tubularSegments, r, radialSegments, true);
            
            const material = new THREE.MeshStandardMaterial({
                color: 0xD4AF37, // 차분한 금색
                metalness: 0.8,
                roughness: 0.4, // 반사를 줄여 은은하게
                emissive: 0x1a1a00, // 자체 발광을 줄임
            });

            const ilwonsang = new THREE.Mesh(geometry, material);
            scene.add(ilwonsang);

            // 5. 조명(Light) 생성
            // 전체적인 기본 밝기를 제공
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // 정면 조명
            const pointLight1 = new THREE.PointLight(0xffffff, 0.7);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);
            
            // 후면 조명 (그림자 방지)
            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-5, -5, -5);
            scene.add(pointLight2);


            // 6. 컨트롤(Controls) 생성
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.enableZoom = true; // 줌 기능 활성화
            controls.minZoom = 0.5; // Orthographic 카메라 줌 범위 설정
            controls.maxZoom = 2;

            // 7. 애니메이션 루프
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // 8. 창 크기 조절 대응
            window.addEventListener('resize', () => {
                const newAspect = window.innerWidth / window.innerHeight;
                camera.left = frustumSize * newAspect / -2;
                camera.right = frustumSize * newAspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        })();
    </script>
</body>
</html>

